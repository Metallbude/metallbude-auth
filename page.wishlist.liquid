{% comment %}
  Metallbude Wishlist Page - Exact Collection Style Match
  - Clean minimalist design matching Metallbude's aesthetic
  - Three-column grid layout like their collections
  - Square product cards with minimal hover effects
  - Consistent typography using system fonts
  - Black, white, beige color scheme
{% endcomment %}

<div class="wishlist-page">
  <div class="container">
    <div class="wishlist-header">
      <h1 class="wishlist-title">
        <svg class="heart-icon" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5c0-3.08 2.42-5.5 5.5-5.5 1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
        </svg>
        MEINE WUNSCHLISTE
      </h1>
      <p class="wishlist-subtitle">Deine gespeicherten Lieblingsprodukte</p>
    </div>

    <div class="wishlist-content">
      <!-- Loading State -->
      <div id="wishlist-loading" class="loading-state">
        <div class="loading-spinner"></div>
        <p>Lade deine Wunschliste...</p>
      </div>

      <!-- Empty State -->
      <div id="wishlist-empty" class="empty-state" style="display: none;">
        <div class="empty-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
          </svg>
        </div>
        <h3>DEINE WUNSCHLISTE IST LEER</h3>
        <p>Entdecke unsere Produkte und fÃ¼ge deine Favoriten hinzu!</p>
        <a href="/collections/all" class="btn-primary">JETZT STÃ–BERN</a>
      </div>

      <!-- Error State -->
      <div id="wishlist-error" class="error-state" style="display: none;">
        <div class="error-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="10"/>
            <line x1="15" y1="9" x2="9" y2="15"/>
            <line x1="9" y1="9" x2="15" y2="15"/>
          </svg>
        </div>
        <h3>FEHLER BEIM LADEN</h3>
        <p>Entschuldigung, deine Wunschliste konnte nicht geladen werden.</p>
        <button id="retry-btn" class="btn-secondary">ERNEUT VERSUCHEN</button>
      </div>

      <!-- Filter & Sort Bar (Metallbude Style) -->
      <div id="filter-bar" class="filter-bar" style="display: none;">
        <div class="filter-left">
          <span class="results-count">8 Produkte</span>
        </div>
        <div class="filter-right">
          <select class="sort-select">
            <option value="default">AusgewÃ¤hlt</option>
            <option value="price-low">Preis aufsteigend</option>
            <option value="price-high">Preis absteigend</option>
            <option value="name">Alphabetisch</option>
          </select>
        </div>
      </div>

      <!-- Wishlist Grid - Exact Metallbude Collection Layout -->
      <div id="wishlist-items" class="wishlist-grid" style="display: none;">
        <!-- Products will be loaded here -->
      </div>
    </div>
  </div>
</div>

<!-- Mobile Debug Info (only visible in development) -->
<div id="mobile-debug" class="mobile-debug" style="display: none;">
  <h4>ðŸ”§ Mobile Debug Info</h4>
  <div id="debug-info"></div>
  <button onclick="document.getElementById('mobile-debug').style.display='none'">Close</button>
</div>

<style>
/* Metallbude Collection Page - Exact Style Match */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.wishlist-page {
  max-width: 1200px;
  margin: 0 auto;
  padding: 40px 20px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: #FCFBF9;
  color: #000000;
  line-height: 1.4;
}

.container {
  width: 100%;
}

/* Header - Metallbude Style */
.wishlist-header {
  text-align: center;
  margin-bottom: 60px;
}

.wishlist-title {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 1.8rem;
  font-weight: 600;
  color: #000000;
  margin-bottom: 12px;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

.heart-icon {
  width: 20px;
  height: 20px;
  color: #000000;
}

.wishlist-subtitle {
  font-size: 0.85rem;
  color: #666666;
  margin: 0;
  font-weight: 400;
  text-transform: none;
  letter-spacing: 0;
}

/* Filter Bar - Metallbude Style */
.filter-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 40px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e8e8e8;
}

.results-count {
  font-size: 0.85rem;
  color: #666666;
  font-weight: 400;
}

/* Sort Select - 20px Border Radius */
.sort-select {
  background: #ffffff;
  border: 1px solid #e8e8e8;
  border-radius: 20px;
  padding: 8px 12px;
  font-size: 0.85rem;
  color: #000000;
  cursor: pointer;
  min-width: 160px;
  font-weight: 400;
}

.sort-select:focus {
  outline: none;
  border-color: #000000;
}

/* Loading State */
.loading-state {
  text-align: center;
  padding: 120px 20px;
}

.loading-spinner {
  width: 30px;
  height: 30px;
  border: 2px solid #f0f0f0;
  border-top: 2px solid #000000;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 24px;
}

.loading-state p {
  color: #666666;
  font-size: 0.9rem;
  font-weight: 400;
}

/* Empty & Error States */
.empty-state, .error-state {
  text-align: center;
  padding: 120px 20px;
}

.empty-icon svg, .error-icon svg {
  width: 60px;
  height: 60px;
  color: #cccccc;
  margin-bottom: 32px;
}

.error-icon svg {
  color: #dc3545;
}

.empty-state h3, .error-state h3 {
  font-size: 1.2rem;
  color: #000000;
  margin-bottom: 16px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.empty-state p, .error-state p {
  color: #666666;
  font-size: 0.9rem;
  margin-bottom: 32px;
  font-weight: 400;
}

/* Buttons - 20px Border Radius */
.btn-primary, .btn-secondary {
  display: inline-block;
  padding: 12px 24px;
  font-size: 0.8rem;
  font-weight: 500;
  text-decoration: none;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  border: none;
  font-family: inherit;
  border-radius: 20px;
}

.btn-primary {
  background: #000000;
  color: #ffffff;
}

.btn-primary:hover {
  background: #333333;
}

.btn-secondary {
  background: #ffffff;
  color: #000000;
  border: 1px solid #e8e8e8;
}

.btn-secondary:hover {
  background: #f8f8f8;
  border-color: #cccccc;
}

/* Wishlist Grid - Responsive Card Layout */
.wishlist-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr); /* Desktop: 5 products per row */
  gap: 48px 20px; /* More space between rows, tight columns */
  margin-top: 0;
}

/* Product Card - Flexbox Layout for Perfect Button Alignment */
.product-card {
  background: #FCFBF9; /* Same as page background */
  border: none;
  border-radius: 20px;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  /* Remove fixed height - let content determine height */
  box-shadow: none;
}

.product-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.08);
}

/* âœ… Beautiful smooth removal animation with slide and fade */
.product-card.removing {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  transform: translateX(-100%) scale(0.9);
  opacity: 0;
  filter: blur(2px);
  z-index: -1;
}

/* Loading state for remove button */
.product-card.removing .remove-btn {
  opacity: 0;
  pointer-events: none;
}

/* Smooth grid reflow when items are removed */
.wishlist-grid {
  transition: grid-template-columns 0.3s ease;
}

/* Additional animation states */
.product-card.removing-fade-only {
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
  opacity: 0;
  transform: scale(0.95);
}

.product-card.removing-slide-up {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  transform: translateY(-30px) scale(0.9);
  opacity: 0;
}

/* Product Image - 1.5:1 Portrait Aspect Ratio */
.product-image {
  width: 100%;
  aspect-ratio: 1/1.5; /* Portrait mode - 1.5:1 ratio (taller than wide) */
  background: #FCFBF9; /* Same as page background */
  position: relative;
  overflow: hidden;
  margin-bottom: 16px;
  border-radius: 16px;
  flex-shrink: 0; /* Don't shrink the image */
  transition: transform 0.2s ease;
  cursor: pointer; /* Added cursor pointer */
}

.product-image:hover {
  transform: scale(1.02); /* Subtle scale on hover to indicate clickability */
}

.product-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: none; /* No zoom effects */
}

.product-image svg {
  width: 32px;
  height: 32px;
  color: #cccccc;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* Product Info - Flexible content area with forced button alignment */
.product-info {
  display: flex;
  flex-direction: column;
  flex: 1; /* Take remaining space */
  padding: 0 16px 16px 16px;
  background: #FCFBF9; /* Same background as page */
  border-radius: 0 0 20px 20px; /* Round bottom corners to match card */
}

.product-content {
  flex: 1; /* Take available space */
  display: flex;
  flex-direction: column;
}

.product-actions {
  margin-top: auto; /* Always push to bottom */
  padding-top: 12px;
}

/* Remove Button - Always Visible with consistent design across all devices */
.remove-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(255, 255, 255, 0.95);
  color: #666666;
  border: none;
  width: 32px;
  height: 32px;
  border-radius: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 1; /* Always visible */
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  z-index: 20; /* Higher z-index to ensure it's clickable */
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  /* Mobile-friendly properties */
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

.remove-btn:hover {
  color: #dc3545;
  background: rgba(255, 255, 255, 1);
  transform: scale(1.05);
}

.remove-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

/* Prevent parent click events when clicking on remove button */
.remove-btn * {
  pointer-events: none;
}

/* Product Badge (Sale, Bestseller) */
.product-badge {
  position: absolute;
  top: 12px;
  left: 12px;
  background: #000000;
  color: #ffffff;
  font-size: 0.6rem;
  padding: 4px 8px;
  border-radius: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
  z-index: 15;
}

.product-badge-sale {
  background: #28a745; /* Green for sale */
}

/* Product Title - Consistent Height */
.product-title {
  font-size: 0.75rem; /* Smaller text size */
  font-weight: 500; /* Lighter weight */
  color: #000000;
  margin-bottom: 4px; /* Reduced gap */
  line-height: 1.3;
  text-transform: uppercase;
  letter-spacing: 0.3px; /* Reduced letter spacing */
  text-decoration: none;
  display: block;
  text-align: center; /* Centered */
  min-height: 2.6em; /* Reserve space for 2 lines of text */
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* Limit to 2 lines */
  -webkit-box-orient: vertical;
}

.product-title:hover {
  text-decoration: underline;
}

.product-vendor {
  display: none; /* Metallbude doesn't show vendor */
}

/* Product Price */
.product-price {
  color: #000000;
  font-weight: 500;
  font-size: 0.75rem; /* Same size as title */
  margin-bottom: 12px; /* Reduced margin */
  text-align: center; /* Centered */
  min-height: 1.3em; /* Consistent height for price */
}

.product-price-from {
  font-size: 0.68rem; /* Smaller text */
  color: #666666;
  font-weight: 400;
  margin-right: 4px;
  text-transform: lowercase;
}

/* Sale Price Styling */
.product-price-sale {
  color: #28a745; /* Green sale price */
  font-weight: 600;
}

.product-price-compare {
  color: #666666;
  text-decoration: line-through;
  font-size: 0.68rem;
  margin-right: 6px;
}

.product-sale-badge {
  background: #28a745;
  color: white;
  font-size: 0.6rem;
  padding: 2px 6px;
  border-radius: 8px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
  margin-left: 4px;
}

/* Color Swatches - Variant Display */
.product-swatches {
  display: flex;
  align-items: center;
  justify-content: center; /* Center the swatches */
  gap: 6px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  min-height: 20px; /* Consistent space even when no swatches */
}

.swatch {
  width: 16px;
  height: 16px;
  border-radius: 8px;
  border: 1px solid #e8e8e8;
  cursor: pointer;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.swatch:hover {
  transform: scale(1.1);
  border-color: #000000;
}

.swatch-text {
  font-size: 0.68rem; /* Slightly smaller */
  color: #666666;
  font-weight: 400;
  text-align: center; /* Center the text */
}

/* Metallbude Color Definitions */
.swatch[data-color="schwarz"] { background-color: #000000; }
.swatch[data-color="weiÃŸ"] { background-color: #ffffff; border-color: #cccccc; }
.swatch[data-color="cashew"] { background-color: #d4b896; }
.swatch[data-color="blueberry-soda"] { background-color: #6b8dd6; }
.swatch[data-color="mango-lassi"] { background-color: #ffa726; }
.swatch[data-color="matcha-latte"] { background-color: #8bc34a; }
.swatch[data-color="pink-lemonade"] { background-color: #f06292; }
.swatch[data-color="beige"] { background-color: #f5f1eb; }

/* Action Button - Consistent Bottom Alignment */
.btn-view {
  display: block;
  width: 100%;
  padding: 12px 0;
  background: transparent;
  color: #000000;
  border: 1px solid #000000;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 500;
  text-decoration: none;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: auto; /* This ensures button stays at bottom */
}

.btn-view:hover {
  background: #000000;
  color: #ffffff;
}

/* Success Message - 20px Border Radius */
.success-message {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #000000;
  color: #ffffff;
  padding: 16px 24px;
  border-radius: 20px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  z-index: 1000;
  animation: slideIn 0.3s ease;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 0.8rem;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(100%); }
  to { opacity: 1; transform: translateX(0); }
}

/* âœ… Loading animation for remove button */
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Responsive Design - Fixed Grid Layout */
@media (max-width: 1200px) {
  .wishlist-grid {
    grid-template-columns: repeat(4, 1fr);
    gap: 40px 18px;
  }
}

@media (max-width: 1024px) {
  .wishlist-grid {
    grid-template-columns: repeat(3, 1fr);
    gap: 36px 16px;
  }
}

@media (max-width: 768px) {
  .wishlist-page {
    padding: 24px 16px;
  }
  
  .wishlist-header {
    margin-bottom: 40px;
  }
  
  .wishlist-title {
    font-size: 1.5rem;
    flex-direction: column;
    gap: 8px;
  }
  
  .filter-bar {
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;
  }
  
  .wishlist-grid {
    grid-template-columns: repeat(2, 1fr); /* Mobile: 2 products per row */
    gap: 32px 12px;
  }
  
  /* Remove fixed height - let content determine height */
  
  /* Keep same 1.5:1 aspect ratio on mobile */
  .product-image {
    aspect-ratio: 1/1.5; /* Same as desktop - 1.5:1 portrait */
    margin-bottom: 16px; /* Same as desktop */
  }
  
  .product-info {
    padding: 0 16px 16px 16px; /* Same as desktop */
  }
}

@media (max-width: 480px) {
  .wishlist-page {
    padding: 20px 12px;
  }
  
  .wishlist-grid {
    grid-template-columns: repeat(2, 1fr); /* Keep 2 columns even on small mobile */
    gap: 20px 8px;
  }
  
  .wishlist-title {
    font-size: 1.3rem;
  }
  
  .product-card {
    min-height: 480px; /* Keep consistent height */
  }
  
  .product-title {
    font-size: 0.75rem;
    line-height: 1.2;
  }
  
  .product-price {
    font-size: 0.8rem;
  }
  
  /* Keep desktop remove button size - no mobile overrides */
  
  /* Improve loading and error states for mobile */
  .loading-state,
  .empty-state,
  .error-state {
    padding: 40px 20px;
    text-align: center;
  }
  
  .btn-primary,
  .btn-secondary {
    padding: 12px 24px;
    font-size: 0.9rem;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
}

/* Mobile Debug Overlay */
.mobile-debug {
  position: fixed;
  top: 10px;
  left: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 15px;
  border-radius: 8px;
  z-index: 9999;
  font-size: 12px;
  line-height: 1.4;
  max-height: 50vh;
  overflow-y: auto;
}

.mobile-debug h4 {
  margin: 0 0 10px 0;
  color: #00ff00;
}

.mobile-debug button {
  margin-top: 10px;
  padding: 5px 10px;
  background: #333;
  color: white;
  border: 1px solid #666;
  border-radius: 4px;
  cursor: pointer;
}

/* High contrast focus states for accessibility */
.btn-primary:focus,
.btn-secondary:focus,
.sort-select:focus {
  outline: 2px solid #000000;
  outline-offset: 2px;
}
</style>

<script>
// Metallbude Style Wishlist Manager - Clean Collection Page Experience
class MetallbudeWishlistManager {
  constructor() {
    this.backendUrl = 'https://metallbude-auth.onrender.com';
    this.customerId = this.getCustomerId();
    this.products = [];
    this.init();
  }

  getCustomerId() {
    {% if customer %}
      return '{{ customer.id }}';
    {% else %}
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('customer_id') || localStorage.getItem('temp_customer_id') || null;
    {% endif %}
  }

  async init() {
    console.log('ðŸ”¥ Metallbude Wishlist Manager initialized');
    console.log('ðŸ†” Customer ID:', this.customerId);
    console.log('ðŸŒ Backend URL:', this.backendUrl);
    console.log('ðŸ“± Device info:', {
      isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
      isAndroid: /Android/.test(navigator.userAgent),
      touchSupport: 'ontouchstart' in window,
      cookiesEnabled: navigator.cookieEnabled,
      localStorage: typeof(Storage) !== "undefined"
    });
    
    if (!this.customerId) {
      console.warn('âš ï¸ No customer ID found');
      console.log('ðŸ” Checking alternative customer ID sources...');
      
      // Try alternative ways to get customer ID for mobile
      const urlCustomerId = new URLSearchParams(window.location.search).get('customer_id');
      const storageCustomerId = localStorage.getItem('temp_customer_id');
      
      console.log('ðŸ” URL customer ID:', urlCustomerId);
      console.log('ðŸ” Storage customer ID:', storageCustomerId);
      
      if (urlCustomerId) {
        this.customerId = urlCustomerId;
        console.log('âœ… Using URL customer ID:', this.customerId);
      } else if (storageCustomerId) {
        this.customerId = storageCustomerId;
        console.log('âœ… Using storage customer ID:', this.customerId);
      } else {
        this.showEmpty();
        return;
      }
    }

    // Add a small delay for mobile browsers to ensure DOM is fully ready
    setTimeout(() => {
      this.loadWishlist();
      this.setupEventListeners();
    }, 100);
  }

  setupEventListeners() {
    // Sort functionality
    const sortSelect = document.querySelector('.sort-select');
    if (sortSelect) {
      sortSelect.addEventListener('change', (e) => {
        this.sortProducts(e.target.value);
      });
    }

    // Retry button with both click and touch events
    const retryBtn = document.getElementById('retry-btn');
    if (retryBtn) {
      retryBtn.addEventListener('click', () => this.loadWishlist());
      retryBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        this.loadWishlist();
      });
    }

    // Touch tracking for distinguishing scroll vs tap
    this.touchData = {
      startX: 0,
      startY: 0,
      startTime: 0,
      moved: false,
      threshold: 5, // More sensitive - 5 pixels moved before considering it a scroll
      isScrolling: false,
      touchTarget: null
    };

    // Event delegation for remove buttons (desktop only)
    document.addEventListener('click', (e) => {
      const removeBtn = e.target.closest('.remove-btn');
      if (removeBtn) {
        // Prevent event bubbling and default behavior
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        const productGid = removeBtn.getAttribute('data-product-gid');
        const variantId = removeBtn.getAttribute('data-variant-id');
        
        console.log('Remove button clicked:', productGid, variantId);
        this.removeItemSafe(e, productGid, variantId);
        return false;
      }

      // Desktop click for product images
      const productImage = e.target.closest('.product-image');
      if (productImage && !e.target.closest('.remove-btn') && !('ontouchstart' in window)) {
        const productUrl = productImage.getAttribute('data-product-url');
        if (productUrl) {
          console.log('Desktop: Navigating to product:', productUrl);
          window.location.href = productUrl;
        }
      }
    });

    // Listen for scroll events to detect active scrolling
    let scrollTimeout;
    document.addEventListener('scroll', () => {
      if ('ontouchstart' in window) {
        this.touchData.isScrolling = true;
        console.log('Mobile: Scroll event detected');
        
        // Clear existing timeout
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
        
        // Reset scrolling state after scroll stops
        scrollTimeout = setTimeout(() => {
          this.touchData.isScrolling = false;
          console.log('Mobile: Scroll stopped');
        }, 150);
      }
    }, { passive: true });

    // Mobile touch handling with proper scroll detection
    if ('ontouchstart' in window) {
      // Touch start - record initial position
      document.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        this.touchData.startX = touch.clientX;
        this.touchData.startY = touch.clientY;
        this.touchData.startTime = Date.now();
        this.touchData.moved = false;
        this.touchData.isScrolling = false;
        this.touchData.touchTarget = e.target;
        console.log('Mobile: Touch start on', e.target.tagName, e.target.className);
      }, { passive: true });

      // Touch move - detect if user is scrolling
      document.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        const deltaX = Math.abs(touch.clientX - this.touchData.startX);
        const deltaY = Math.abs(touch.clientY - this.touchData.startY);
        
        // If moved more than threshold, consider it scrolling
        if (deltaX > this.touchData.threshold || deltaY > this.touchData.threshold) {
          this.touchData.moved = true;
          this.touchData.isScrolling = true;
          console.log('Mobile: Scroll detected - deltaX:', deltaX, 'deltaY:', deltaY);
        }
      }, { passive: true });

      // Touch end - only navigate if it wasn't a scroll
      document.addEventListener('touchend', (e) => {
        const touchDuration = Date.now() - this.touchData.startTime;
        
        console.log('Mobile: Touch end - moved:', this.touchData.moved, 'isScrolling:', this.touchData.isScrolling, 'duration:', touchDuration);
        
        const removeBtn = e.target.closest('.remove-btn');
        if (removeBtn) {
          // Remove button - always work regardless of movement
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          
          const productGid = removeBtn.getAttribute('data-product-gid');
          const variantId = removeBtn.getAttribute('data-variant-id');
          
          console.log('Remove button touched:', productGid, variantId);
          this.removeItemSafe(e, productGid, variantId);
          return false;
        }

        // Product navigation - only if it was a tap, not a scroll
        const productImage = e.target.closest('.product-image');
        if (productImage && !e.target.closest('.remove-btn')) {
          // Only navigate if:
          // 1. User didn't move much (not scrolling)
          // 2. Touch was brief (not a long press)
          // 3. Touch duration was reasonable for a tap
          // 4. Not currently in a scrolling state
          const isValidTap = !this.touchData.moved && 
                            !this.touchData.isScrolling && 
                            touchDuration < 400 && 
                            touchDuration > 30;
          
          if (isValidTap) {
            const productUrl = productImage.getAttribute('data-product-url');
            if (productUrl) {
              e.preventDefault(); // Prevent ghost click
              console.log('Mobile: Valid tap detected, navigating to product:', productUrl);
              window.location.href = productUrl;
            }
          } else {
            console.log(`Mobile: Tap ignored - moved: ${this.touchData.moved}, scrolling: ${this.touchData.isScrolling}, duration: ${touchDuration}ms`);
          }
        }
        
        // Reset scrolling state after a short delay
        setTimeout(() => {
          this.touchData.isScrolling = false;
        }, 100);
      }, { passive: false });

      // Touch cancel - reset state when touch is interrupted
      document.addEventListener('touchcancel', (e) => {
        console.log('Mobile: Touch cancelled');
        this.touchData.moved = false;
        this.touchData.isScrolling = false;
      }, { passive: true });
    }
  }

  async loadWishlist() {
    try {
      console.log('ðŸ“¥ Loading wishlist...');
      console.log('ðŸ“± User Agent:', navigator.userAgent);
      console.log('ðŸŒ Online status:', navigator.onLine);
      
      this.showLoading();
      
      const apiUrl = `${this.backendUrl}/api/public/wishlist/items?customerId=${this.customerId}`;
      console.log('ðŸŒ Loading from:', apiUrl);
      
      // Add timeout for mobile networks and better error handling
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
      
      try {
        const response = await fetch(apiUrl, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          credentials: 'omit',
          mode: 'cors',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        console.log('ðŸ“¡ Load response status:', response.status);
        console.log('ðŸ“¡ Load response headers:', Object.fromEntries(response.headers.entries()));
        
        if (!response.ok) {
          throw new Error(`Backend error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('ðŸ“¡ Load response data:', data);
        
        if (!data.success) {
          console.error('âŒ API returned error:', data.error || 'Unknown error');
          throw new Error(data.error || 'API returned unsuccessful response');
        }
        
        if (!data.items || data.items.length === 0) {
          console.log('ðŸ“­ No items found, showing empty state');
          this.showEmpty();
          return;
        }

        console.log(`ðŸ“¦ Found ${data.items.length} items in wishlist`);
        await this.displayWishlistItems(data.items);
        
      } catch (fetchError) {
        clearTimeout(timeoutId);
        if (fetchError.name === 'AbortError') {
          throw new Error('Request timeout - please check your internet connection');
        }
        throw fetchError;
      }
      
    } catch (error) {
      console.error('ðŸ”¥ Error loading wishlist:', error);
      console.error('ðŸ”¥ Error stack:', error.stack);
      
      // Show detailed error information for debugging
      if (error.message.includes('timeout')) {
        console.error('ðŸŒ Network timeout - possibly slow mobile connection');
      } else if (error.message.includes('CORS')) {
        console.error('ðŸš« CORS error - check domain settings');
      } else if (error.message.includes('Failed to fetch')) {
        console.error('ðŸŒ Network error - check internet connection');
      }
      
      // Show debug info on mobile devices when there's an error
      const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (isMobile) {
        console.log('ðŸ“± Mobile device detected, showing debug info...');
        setTimeout(() => this.showMobileDebug(), 1000);
      }
      
      this.showError(error.message);
    }
  }

  async displayWishlistItems(items) {
    this.hideAllStates();
    document.getElementById('wishlist-items').style.display = 'grid';
    document.getElementById('filter-bar').style.display = 'flex';
    
    const productData = items.map(item => ({
      productId: this.extractProductId(item.productId),
      variantId: item.variantId || null,
      originalItem: item
    }));
    
    this.products = await this.fetchRealProductData(productData);
    this.renderProducts();
    this.updateResultsCount();
  }

  extractProductId(shopifyGid) {
    if (typeof shopifyGid === 'string' && shopifyGid.includes('gid://shopify/Product/')) {
      return shopifyGid.split('/').pop();
    }
    return shopifyGid;
  }

  extractVariantId(shopifyGid) {
    if (typeof shopifyGid === 'string' && shopifyGid.includes('gid://shopify/ProductVariant/')) {
      return shopifyGid.split('/').pop();
    }
    return shopifyGid;
  }

  async fetchRealProductData(productDataArray) {
    const products = [];
    
    try {
      const collectionsResponse = await fetch(`/collections/all/products.json?limit=250`);
      
      if (collectionsResponse.ok) {
        const collectionsData = await collectionsResponse.json();
        
        productDataArray.forEach(productData => {
          const productId = productData.productId;
          const variantId = productData.variantId;
          const foundProduct = collectionsData.products.find(p => p.id.toString() === productId);
          
          if (foundProduct) {
            const variants = foundProduct.variants || [];
            let selectedVariant = null;
            if (variantId) {
              selectedVariant = variants.find(v => v.id.toString() === variantId.toString());
            }
            
            // Try to extract color from wishlist item data first (more reliable)
            let selectedColor = this.extractColorFromWishlistItem(productData.originalItem);
            
            // Fall back to variant extraction if no color found in wishlist data
            if (!selectedColor && selectedVariant) {
              selectedColor = this.extractColorFromVariant(selectedVariant);
            }
            
            // Only show the selected color if we have one, otherwise show no swatches
            const displayColors = selectedColor ? [selectedColor] : [];
            
            // Use the selected variant's image if available, otherwise fallback to product featured image
            let productImage = foundProduct.images && foundProduct.images[0] ? foundProduct.images[0].src : null;
            if (selectedVariant && selectedVariant.featured_image) {
              productImage = selectedVariant.featured_image.src;
            }
            
            // Use the selected variant's price if available
            let productPrice = (foundProduct.variants[0] && foundProduct.variants[0].price) || '0.00';
            let compareAtPrice = (foundProduct.variants[0] && foundProduct.variants[0].compare_at_price) || null;
            if (selectedVariant && selectedVariant.price) {
              productPrice = selectedVariant.price;
              compareAtPrice = selectedVariant.compare_at_price || null;
            }
            
            // âœ… Build URL with variant information if available
            let productUrl = `/products/${foundProduct.handle}`;
            
            // First priority: Use variant ID from API response (most reliable)
            if (productData.originalItem && productData.originalItem.variantId) {
              const apiVariantId = this.extractVariantId(productData.originalItem.variantId);
              if (apiVariantId) {
                productUrl += `?variant=${apiVariantId}`;
              }
            } else if (selectedVariant && selectedVariant.id) {
              // Fallback: Use selected variant from product data
              productUrl += `?variant=${selectedVariant.id}`;
            }
            
            products.push({
              id: productId,
              gid: (productData.originalItem && productData.originalItem.productId) || `gid://shopify/Product/${productId}`, // âœ… Use original Firebase product ID (with full GID) or fallback
              title: foundProduct.title,
              handle: foundProduct.handle,
              featuredImage: productImage,
              price: productPrice,
              compareAtPrice: compareAtPrice, // Add compare at price
              priceMin: Math.min(...variants.map(v => parseFloat(v.price || 0))),
              priceMax: Math.max(...variants.map(v => parseFloat(v.price || 0))),
              available: foundProduct.available,
              vendor: foundProduct.vendor || '',
              url: productUrl, // âœ… Use URL with variant parameter
              colors: displayColors, // Only show the selected color swatch
              selectedColor: selectedColor,
              selectedVariant: selectedVariant,
              variants: variants,
              tags: foundProduct.tags || [],
              isReal: true,
              // Store original wishlist item data for better variant handling
              wishlistItemData: productData.originalItem
            });
          } else {
            products.push({
              id: productId,
              gid: (productData.originalItem && productData.originalItem.productId) || `gid://shopify/Product/${productId}`, // âœ… Use original Firebase product ID (with full GID) or fallback
              title: `Produkt ${productId}`,
              handle: productId,
              featuredImage: null,
              price: '0.00',
              priceMin: 0,
              priceMax: 0,
              available: true,
              vendor: '',
              url: `/products/${productId}`,
              colors: [],
              selectedColor: null,
              selectedVariant: null,
              variants: [],
              tags: [],
              isReal: false
            });
          }
        });
      }
      
    } catch (error) {
      console.error('ðŸ”¥ Error fetching product data:', error);
    }
    
    return products;
  }

  extractColorFromVariant(variant) {
    const options = [variant.option1, variant.option2, variant.option3];
    for (const option of options) {
      if (option) {
        const colorName = option.toLowerCase().trim();
        if (colorName.includes('schwarz') || colorName.includes('black')) return 'schwarz';
        else if (colorName.includes('weiÃŸ') || colorName.includes('white')) return 'weiÃŸ';
        else if (colorName.includes('cashew')) return 'cashew';
        else if (colorName.includes('blueberry') || colorName.includes('soda')) return 'blueberry-soda';
        else if (colorName.includes('mango') || colorName.includes('lassi')) return 'mango-lassi';
        else if (colorName.includes('matcha') || colorName.includes('latte')) return 'matcha-latte';
        else if (colorName.includes('pink') || colorName.includes('lemonade')) return 'pink-lemonade';
        else if (colorName.includes('beige')) return 'beige';
      }
    }
    return null;
  }

  // Extract color from wishlist item's selectedOptions
  extractColorFromWishlistItem(wishlistItem) {
    if (!wishlistItem || !wishlistItem.selectedOptions) {
      return null;
    }
    
    // Check various possible option names for color
    const colorKeys = [
      'Color', 'Farbe', 'Colour', 'color', 'farbe', 'colour',
      'Leder Farbe', 'Haken Farbe', 'Korpus Farbe', 'Gestell Farbe'
    ];
    
    for (const key of colorKeys) {
      if (wishlistItem.selectedOptions[key]) {
        const colorValue = wishlistItem.selectedOptions[key].toLowerCase().trim();
        if (colorValue.includes('schwarz') || colorValue.includes('black')) return 'schwarz';
        else if (colorValue.includes('weiÃŸ') || colorValue.includes('white')) return 'weiÃŸ';
        else if (colorValue.includes('cashew')) return 'cashew';
        else if (colorValue.includes('blueberry') || colorValue.includes('soda')) return 'blueberry-soda';
        else if (colorValue.includes('mango') || colorValue.includes('lassi')) return 'mango-lassi';
        else if (colorValue.includes('matcha') || colorValue.includes('latte')) return 'matcha-latte';
        else if (colorValue.includes('pink') || colorValue.includes('lemonade')) return 'pink-lemonade';
        else if (colorValue.includes('beige')) return 'beige';
      }
    }
    
    return null;
  }

  // Get readable selected option text from wishlist item
  getSelectedOptionText(wishlistItem) {
    if (!wishlistItem || !wishlistItem.selectedOptions) {
      return null;
    }
    
    // Look for color options specifically
    const colorKeys = [
      'Color', 'Farbe', 'Colour', 'color', 'farbe', 'colour',
      'Leder Farbe', 'Haken Farbe', 'Korpus Farbe', 'Gestell Farbe'
    ];
    
    for (const key of colorKeys) {
      if (wishlistItem.selectedOptions[key]) {
        return wishlistItem.selectedOptions[key];
      }
    }
    
    // If no color found, return the first available option
    const options = Object.entries(wishlistItem.selectedOptions);
    if (options.length > 0) {
      return options[0][1]; // Return first option value
    }
    
    return null;
  }

  extractColorsFromVariants(variants) {
    const colors = new Set();
    variants.forEach(variant => {
      const options = [variant.option1, variant.option2, variant.option3];
      options.forEach(option => {
        if (option) {
          const colorName = option.toLowerCase().trim();
          if (colorName.includes('schwarz') || colorName.includes('black')) colors.add('schwarz');
          else if (colorName.includes('weiÃŸ') || colorName.includes('white')) colors.add('weiÃŸ');
          else if (colorName.includes('cashew')) colors.add('cashew');
          else if (colorName.includes('blueberry') || colorName.includes('soda')) colors.add('blueberry-soda');
          else if (colorName.includes('mango') || colorName.includes('lassi')) colors.add('mango-lassi');
          else if (colorName.includes('matcha') || colorName.includes('latte')) colors.add('matcha-latte');
          else if (colorName.includes('pink') || colorName.includes('lemonade')) colors.add('pink-lemonade');
          else if (colorName.includes('beige')) colors.add('beige');
        }
      });
    });
    return Array.from(colors);
  }

  renderProducts() {
    const grid = document.getElementById('wishlist-items');
    grid.innerHTML = '';

    this.products.forEach(product => {
      const productCard = this.createMetallbudeProductCard(product);
      grid.appendChild(productCard);
    });
  }

  createMetallbudeProductCard(product) {
    const card = document.createElement('div');
    card.className = 'product-card';
    
    // Image HTML - prioritize variant image if available
    let imageHtml;
    let imageUrl = product.featuredImage;
    
    // Check if we have a specific variant image from wishlist data (API imageUrl) or selected variant
    if (product.wishlistItemData && product.wishlistItemData.imageUrl) {
      imageUrl = product.wishlistItemData.imageUrl;
    } else if (product.wishlistItemData && product.wishlistItemData.variantImage) {
      imageUrl = product.wishlistItemData.variantImage;
    } else if (product.selectedVariant && product.selectedVariant.image && product.selectedVariant.image.url) {
      imageUrl = product.selectedVariant.image.url;
    } else if (product.selectedVariant && product.selectedVariant.featured_image && product.selectedVariant.featured_image.src) {
      // Fallback for Shopify variant image structure
      imageUrl = product.selectedVariant.featured_image.src;
    }
    
    if (imageUrl) {
      imageHtml = `<img src="${imageUrl}" alt="${product.title}">`;
    } else {
      imageHtml = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      `;
    }
    
    // Price formatting (German style with comma) with sale price support
    let priceHtml = '';
    if (product.isReal && product.priceMin && product.priceMax) {
      if (product.priceMin === product.priceMax) {
        // Check if this is a sale item
        if (product.compareAtPrice && parseFloat(product.compareAtPrice) > parseFloat(product.price)) {
          priceHtml = `
            <p class="product-price">
              <span class="product-price-compare">${parseFloat(product.compareAtPrice).toFixed(2).replace('.', ',')} EUR</span>
              <span class="product-price-sale">${parseFloat(product.price).toFixed(2).replace('.', ',')} EUR</span>
            </p>
          `;
        } else {
          priceHtml = `<p class="product-price">${product.priceMin.toFixed(2).replace('.', ',')} EUR</p>`;
        }
      } else {
        priceHtml = `<p class="product-price"><span class="product-price-from">ab</span> ${product.priceMin.toFixed(2).replace('.', ',')} EUR</p>`;
      }
    } else if (product.price !== '0.00') {
      // Check if this is a sale item for single price products
      if (product.compareAtPrice && parseFloat(product.compareAtPrice) > parseFloat(product.price)) {
        priceHtml = `
          <p class="product-price">
            <span class="product-price-compare">${parseFloat(product.compareAtPrice).toFixed(2).replace('.', ',')} EUR</span>
            <span class="product-price-sale">${product.price.replace('.', ',')} EUR</span>
          </p>
        `;
      } else {
        priceHtml = `<p class="product-price">${product.price.replace('.', ',')} EUR</p>`;
      }
    }
    
    // Color swatches - show for any product with variant options
    let swatchesHtml = '';
    const optionText = this.getSelectedOptionText(product.wishlistItemData);
    const colorName = this.extractColorFromWishlistItem(product.wishlistItemData);
    
    // Show swatch if we have color information OR any selected options
    if (colorName || optionText) {
      swatchesHtml = `
        <div class="product-swatches">
          <div class="swatch" data-color="${colorName || 'default'}" title="${optionText || colorName || 'Variante'}"></div>
          ${optionText ? `<span class="swatch-text">${optionText}</span>` : ''}
        </div>
      `;
    }

    // Badge for bestsellers and sale items
    let badgeHtml = '';
    const isOnSale = product.compareAtPrice && parseFloat(product.compareAtPrice) > parseFloat(product.price);
    
    if (isOnSale) {
      badgeHtml = '<div class="product-badge product-badge-sale">SALE</div>';
    } else if (product.tags && product.tags.includes('bestseller')) {
      badgeHtml = '<div class="product-badge">BESTSELLER</div>';
    }
    
    card.innerHTML = `
      <div class="product-image" data-product-url="${product.url}">
        ${imageHtml}
        <button class="remove-btn" title="Aus Wunschliste entfernen" data-product-gid="${product.gid}" data-variant-id="${(product.wishlistItemData && product.wishlistItemData.variantId) || (product.selectedVariant ? product.selectedVariant.id : '')}" type="button">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="product-info">
        <div class="product-content">
          ${badgeHtml}
          <a href="${product.url}" class="product-title">${product.title}</a>
          ${priceHtml}
          ${swatchesHtml}
        </div>
        <div class="product-actions">
          <a href="${product.url}" class="btn-view">ANSEHEN</a>
        </div>
      </div>
    `;
    
    // Store data attributes for safe removal - use original wishlist item data
    card.dataset.productId = product.gid; // This now contains the original Firebase product ID
    if (product.wishlistItemData && product.wishlistItemData.variantId) {
      card.dataset.variantId = product.wishlistItemData.variantId; // Use original variant ID from wishlist
    } else if (product.selectedVariant) {
      card.dataset.variantId = product.selectedVariant.id;
    }
    if (product.wishlistItemData && product.wishlistItemData.selectedOptions) {
      card.dataset.selectedOptions = JSON.stringify(product.wishlistItemData.selectedOptions);
    }
    
    return card;
  }

  sortProducts(sortType) {
    switch (sortType) {
      case 'price-low':
        this.products.sort((a, b) => (a.priceMin || parseFloat(a.price)) - (b.priceMin || parseFloat(b.price)));
        break;
      case 'price-high':
        this.products.sort((a, b) => (b.priceMin || parseFloat(b.price)) - (a.priceMin || parseFloat(a.price)));
        break;
      case 'name':
        this.products.sort((a, b) => a.title.localeCompare(b.title));
        break;
      default:
        // Keep original order
        break;
    }
    this.renderProducts();
  }

  updateResultsCount() {
    const countElement = document.querySelector('.results-count');
    if (countElement) {
      const count = this.products.length;
      countElement.textContent = `${count} ${count === 1 ? 'Produkt' : 'Produkte'}`;
    }
  }

  async removeItem(productId, variantId = '', selectedOptions = {}) {
    try {
      console.log('ðŸ—‘ï¸ Starting remove item process...');
      console.log('   Product ID:', productId);
      console.log('   Variant ID:', variantId);
      console.log('   Selected Options:', selectedOptions);
      console.log('   Customer ID:', this.customerId);
      
      // Extract numeric product ID from GID if needed
      const cleanProductId = this.extractProductId(productId);
      console.log('   Clean Product ID:', cleanProductId);
      
      // Extract numeric variant ID from GID if needed
      let cleanVariantId = '';
      if (variantId) {
        cleanVariantId = this.extractVariantId(variantId);
        console.log('   Clean Variant ID:', cleanVariantId);
      }
      
      const requestBody = {
        customerId: this.customerId,
        productId: cleanProductId
      };
      
      // Add variant and selected options if provided
      if (cleanVariantId) {
        requestBody.variantId = cleanVariantId;
        console.log('   Added variant ID to request:', cleanVariantId);
      }
      if (selectedOptions && Object.keys(selectedOptions).length > 0) {
        requestBody.selectedOptions = selectedOptions;
        console.log('   Added selected options to request:', selectedOptions);
      }
      
      console.log('ðŸ“¦ Final request body:', JSON.stringify(requestBody, null, 2));
      
      console.log('ðŸ“¦ Request body:', requestBody);
      console.log('ðŸŒ API URL:', `${this.backendUrl}/api/public/wishlist/remove`);
      
      const response = await fetch(`${this.backendUrl}/api/public/wishlist/remove`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        credentials: 'omit',
        mode: 'cors',
        body: JSON.stringify(requestBody)
      });

      console.log('ðŸ“¡ Response status:', response.status);
      const responseData = await response.json();
      console.log('ðŸ“¡ Response data:', responseData);

      if (response.ok && responseData.success) {
        console.log('âœ… Item removed successfully');
        
        // âœ… IMMEDIATE UI UPDATE: Remove the item from display instantly
        this.removeItemFromUI(productId, variantId, selectedOptions);
        
        // âœ… Show success message (count will be updated by removeItemFromUI)
        setTimeout(() => {
          const remainingCount = this.products.length;
          const successMessage = remainingCount > 0 
            ? `ARTIKEL ENTFERNT! (${remainingCount} ${remainingCount === 1 ? 'Artikel' : 'Artikel'} verbleibend)`
            : 'ARTIKEL ENTFERNT! Wunschliste ist leer';
          this.showSuccess(successMessage);
        }, 100);
        
        console.log('âœ… Item removed from UI immediately');
      } else {
        throw new Error(`Remove failed: ${response.status} - ${responseData.error || 'Unknown error'}`);
      }
      
    } catch (error) {
      console.error('ðŸ”¥ Error removing item:', error);
      
      // Show specific error message based on the error type
      let errorMessage = 'Fehler beim Entfernen des Artikels. Bitte versuchen Sie es erneut.';
      if (error.message.includes('404')) {
        errorMessage = 'Artikel wurde bereits entfernt oder nicht gefunden.';
      } else if (error.message.includes('500')) {
        errorMessage = 'Server-Fehler. Bitte versuchen Sie es spÃ¤ter erneut.';
      }
      
      alert(errorMessage);
      
      // Re-throw error so calling function knows it failed
      throw error;
    }
  }

  // Safe remove method that reads data attributes from the clicked element
  async removeItemSafe(clickEvent, productId, variantId) {
    try {
      console.log('ðŸ—‘ï¸ Removing item:', productId, variantId);
      
      const removeBtn = clickEvent.target.closest('.remove-btn');
      if (!removeBtn) {
        console.error('Remove button not found');
        return;
      }

      // Prevent multiple clicks
      if (removeBtn.disabled) {
        console.log('âš ï¸ Remove already in progress');
        return;
      }

      // Disable button and show loading state
      removeBtn.disabled = true;
      removeBtn.style.opacity = '0.5';
      removeBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle></svg>';
      removeBtn.style.animation = 'spin 1s linear infinite';
      
      const productCard = removeBtn.closest('.product-card');
      if (!productCard) {
        console.error('Product card not found');
        removeBtn.disabled = false;
        removeBtn.style.opacity = '1';
        return;
      }

      const selectedOptionsJson = productCard.dataset.selectedOptions;
      
      let selectedOptions = {};
      if (selectedOptionsJson) {
        try {
          selectedOptions = JSON.parse(selectedOptionsJson);
        } catch (e) {
          console.warn('Failed to parse selected options:', e);
        }
      }
      
      console.log('Selected options:', selectedOptions);
      
      // Call remove and wait for completion
      await this.removeItem(productId, variantId, selectedOptions);
      
    } catch (error) {
      console.error('ðŸ”¥ Error in removeItemSafe:', error);
      
      // Re-enable button on error
      const removeBtn = clickEvent.target.closest('.remove-btn');
      if (removeBtn) {
        removeBtn.disabled = false;
        removeBtn.style.opacity = '1';
      }
      
      // Show error message
      alert('Fehler beim Entfernen des Artikels. Bitte versuchen Sie es erneut.');
      
      // Reload wishlist to ensure UI is in sync with server state
      console.log('ðŸ”„ Reloading wishlist due to error...');
      setTimeout(() => {
        this.loadWishlist();
      }, 1000);
    }
  }

  showLoading() {
    this.hideAllStates();
    document.getElementById('wishlist-loading').style.display = 'block';
  }

  showEmpty() {
    this.hideAllStates();
    document.getElementById('wishlist-empty').style.display = 'block';
  }

  showError(errorMessage) {
    this.hideAllStates();
    const errorElement = document.getElementById('wishlist-error');
    
    // Update error message if provided
    if (errorMessage) {
      const errorText = errorElement.querySelector('p');
      if (errorText) {
        errorText.textContent = `Fehler: ${errorMessage}`;
      }
    }
    
    errorElement.style.display = 'block';
  }

  hideAllStates() {
    document.getElementById('wishlist-loading').style.display = 'none';
    document.getElementById('wishlist-empty').style.display = 'none';
    document.getElementById('wishlist-error').style.display = 'none';
    document.getElementById('wishlist-items').style.display = 'none';
    document.getElementById('filter-bar').style.display = 'none';
  }

  showSuccess(message) {
    const successDiv = document.createElement('div');
    successDiv.className = 'success-message';
    successDiv.textContent = message;
    document.body.appendChild(successDiv);
    
    setTimeout(() => {
      successDiv.remove();
    }, 3000);
  }

  // Add debug functionality for mobile troubleshooting
  showMobileDebug() {
    const debugInfo = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      customerId: this.customerId,
      backendUrl: this.backendUrl,
      onLine: navigator.onLine,
      cookieEnabled: navigator.cookieEnabled,
      localStorage: typeof(Storage) !== "undefined",
      fetch: typeof(fetch) !== "undefined",
      windowSize: `${window.innerWidth}x${window.innerHeight}`,
      screenSize: `${screen.width}x${screen.height}`,
      touchSupport: 'ontouchstart' in window,
      customerLoggedIn: '{{ customer }}' !== '',
      shopifyDomain: '{{ shop.permanent_domain }}',
      currentUrl: window.location.href
    };
    
    const debugDiv = document.getElementById('debug-info');
    if (debugDiv) {
      debugDiv.innerHTML = '<pre>' + JSON.stringify(debugInfo, null, 2) + '</pre>';
    }
    
    document.getElementById('mobile-debug').style.display = 'block';
    console.log('ðŸ”§ Mobile Debug Info:', debugInfo);
  }

  // âœ… NEW: Immediately remove item from UI without waiting for reload
  removeItemFromUI(productId, variantId, selectedOptions) {
    try {
      console.log('ðŸŽ¨ Removing item from UI immediately:', { productId, variantId, selectedOptions });
      
      // Find and remove the matching product card from the DOM
      const productCards = document.querySelectorAll('.product-card');
      let matchingCards = [];
      
      productCards.forEach(card => {
        const cardProductId = card.dataset.productId;
        const cardVariantId = card.dataset.variantId;
        const cardSelectedOptions = card.dataset.selectedOptions;
        
        console.log('ðŸ” Checking card:', { cardProductId, cardVariantId, cardSelectedOptions });
        console.log('ðŸ” Looking for:', { productId, variantId, selectedOptions });
        
        // Match by product ID
        if (cardProductId !== productId) {
          console.log('âŒ Product ID mismatch:', cardProductId, '!==', productId);
          return;
        }
        
        // Match by variant ID if provided
        if (variantId && cardVariantId && cardVariantId !== variantId) {
          console.log('âŒ Variant ID mismatch:', cardVariantId, '!==', variantId);
          return;
        }
        
        // Match by selected options if provided
        if (selectedOptions && Object.keys(selectedOptions).length > 0) {
          let cardOptions = {};
          try {
            cardOptions = cardSelectedOptions ? JSON.parse(cardSelectedOptions) : {};
          } catch (e) {
            console.warn('Failed to parse card selected options:', e);
          }
          
          console.log('ðŸ” Comparing options:', JSON.stringify(cardOptions), 'vs', JSON.stringify(selectedOptions));
          if (JSON.stringify(cardOptions) !== JSON.stringify(selectedOptions)) {
            console.log('âŒ Selected options mismatch');
            return;
          }
        }
        
        // This card matches!
        console.log('âœ… Found matching card:', card);
        matchingCards.push(card);
      });
      
      if (matchingCards.length === 0) {
        console.warn('âš ï¸ No matching cards found to remove from UI');
        return;
      }
      
      console.log(`ðŸŽ¨ Found ${matchingCards.length} matching card(s) to remove`);
      
      // Remove each matching card with beautiful animation
      matchingCards.forEach((card, index) => {
        console.log('ðŸŽ¨ Removing card from DOM with enhanced animation:', card);
        
        // Add staggered animation delay for multiple items
        const animationDelay = index * 100; // 100ms delay between each item
        
        setTimeout(() => {
          // Add enhanced removal animation class
          card.classList.add('removing');
          
          // For variety, alternate between different animation styles
          if (index % 3 === 0) {
            card.classList.add('removing-slide-up');
          } else if (index % 3 === 1) {
            card.classList.add('removing-fade-only');
          }
          // Default: side slide animation from CSS
          
          // Remove from DOM after animation completes
          setTimeout(() => {
            if (card.parentNode) {
              card.parentNode.removeChild(card);
              console.log('âœ… Card removed from DOM with animation');
              
              // Update result count
              this.updateResultsCount();
              
              // Check if we need to show empty state
              const remainingCards = document.querySelectorAll('.product-card');
              if (remainingCards.length === 0) {
                console.log('ðŸ“­ No cards remaining, showing empty state');
                this.showEmpty();
              }
            }
          }, 400); // Match the longest CSS animation duration
        }, animationDelay);
      });
      
      // Update the products array immediately (optimistic update)
      this.products = this.products.filter(product => {
        // Remove product if it matches
        if (product.gid === productId || product.id === productId.replace('gid://shopify/Product/', '')) {
          // If we have variant or options matching, be more specific
          if (variantId && product.selectedVariant && product.selectedVariant.id.toString() === variantId) {
            return false; // Remove this product
          }
          if (selectedOptions && Object.keys(selectedOptions).length > 0) {
            const productOptions = (product.wishlistItemData && product.wishlistItemData.selectedOptions) || {};
            if (JSON.stringify(productOptions) === JSON.stringify(selectedOptions)) {
              return false; // Remove this product
            }
          }
          // If no variant/options specified, remove any matching product
          if (!variantId && (!selectedOptions || Object.keys(selectedOptions).length === 0)) {
            return false; // Remove this product
          }
        }
        return true; // Keep this product
      });
      
      console.log(`ðŸŽ¨ Updated products array, ${this.products.length} products remaining`);
      
    } catch (error) {
      console.error('ðŸ”¥ Error removing item from UI:', error);
      // Fall back to full reload if UI update fails
      setTimeout(() => {
        this.loadWishlist();
      }, 500);
    }
  }
}

// Initialize with mobile-friendly approach
function initializeWishlist() {
  try {
    console.log('ðŸ“± Initializing wishlist manager...');
    console.log('ðŸ“± Document ready state:', document.readyState);
    console.log('ðŸ“± Window loaded:', document.readyState === 'complete');
    
    window.wishlistManager = new MetallbudeWishlistManager();
  } catch (error) {
    console.error('âŒ Failed to initialize wishlist manager:', error);
    
    // Show error message to user
    const errorDiv = document.getElementById('wishlist-error');
    if (errorDiv) {
      const errorText = errorDiv.querySelector('p');
      if (errorText) {
        errorText.textContent = 'Fehler beim Laden der Wunschliste. Bitte laden Sie die Seite neu.';
      }
      errorDiv.style.display = 'block';
    }
  }
}

// Multiple initialization strategies for different mobile browsers
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeWishlist);
} else {
  // DOM is already loaded
  initializeWishlist();
}

// Fallback for older mobile browsers
window.addEventListener('load', function() {
  if (!window.wishlistManager) {
    console.log('ðŸ“± Fallback initialization triggered');
    initializeWishlist();
  }
});

// Additional fallback with timeout
setTimeout(function() {
  if (!window.wishlistManager) {
    console.log('ðŸ“± Timeout fallback initialization triggered');
    initializeWishlist();
  }
}, 2000);
</script>